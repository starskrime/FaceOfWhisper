<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S.A.I.A. - Strategic Artificial Intelligence Avatar</title>

    <!-- Tracking.js for Face Detection -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tracking.js/1.1.3/tracking-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tracking.js/1.1.3/data/face-min.js"></script>

    <style>
        body {
            background-color: #000000;
            color: #00FF00;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            cursor: pointer;
            /* Indicate clickable */
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: radical-gradient(circle at center, #051a05 0%, #000000 70%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-text {
            font-size: 14px;
            opacity: 0.7;
            text-shadow: 0 0 5px #00FF00;
        }

        #center-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: #00FF00;
            opacity: 0.5;
            text-align: center;
            letter-spacing: 2px;
            animation: pulse 2s infinite;
            pointer-events: none;
        }

        @keyframes pulse {
            0% {
                opacity: 0.3;
            }

            50% {
                opacity: 0.8;
            }

            100% {
                opacity: 0.3;
            }
        }

        .hidden {
            display: none !important;
        }

        #video {
            position: absolute;
            top: -1000px;
            left: -1000px;
            visibility: hidden;
        }
    </style>
</head>

<body>

    <div id="canvas-container">
        <canvas id="faceCanvas"></canvas>
        <div id="ui-layer">
            <div class="hud-text">SYSTEM: ONLINE<br>TARGET: <span id="target-status">SCANNING...</span></div>
            <div class="hud-text" style="text-align: right;">CPU: 04%<br>MEM: 512TB</div>
        </div>

        <div id="center-text">
            SYSTEM STANDBY<br>
            [ TOUCH TERMINAL TO ENGAGE ]
        </div>

        <!-- Video for Head Tracking -->
        <video id="video" width="640" height="480" preload autoplay loop muted></video>
    </div>

    <script>
        const canvas = document.getElementById('faceCanvas');
        const ctx = canvas.getContext('2d');
        const centerText = document.getElementById('center-text');
        const targetStatus = document.getElementById('target-status');
        const video = document.getElementById('video');

        let width, height;
        let audioContext, analyser, dataArray;
        let nodes = [];
        let isAudioInitialized = false;
        let lastSpeechTime = 0;
        let currentState = 'SPHERE';

        // ARTIFACTS FOR SMART BEHAVIOR
        let trackingX = 0;
        let trackingY = 0;

        let currentYaw = 0;
        let currentPitch = 0;

        let blinkState = 0;
        let blinkValue = 0;
        let nextBlinkTime = Date.now() + 3000;

        // IMPLOSION STATE
        let isFirstSpawn = true;

        // CONFIGURATION
        const config = {
            nodeColor: '#00FF00',
            lineColor: 'rgba(0, 255, 0, 0.12)',
            connectionDistance: 40, // Slightly reduced for density check
            nodeRadius: 0.8, // Finer nodes for hi-fi look
            idleAmplitude: 2.0,
            idleSpeed: 0.0015,
            audioSensitivity: 1.5,
            sphereRadiusRatio: 0.35,
            silenceTimeout: 10000,
            speechThreshold: 5,
            transitionSpeedToFace: 0.15,
            transitionSpeedToSphere: 0.02,
            lookSpeed: 0.05,
            blinkSpeed: 0.2
        };

        // Resize
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            recenterNodes(false); // Do not re-explode on resize
        }
        window.addEventListener('resize', resize);

        // ------------------------------------------------------------------
        // 3D GEOMETRY GENERATION
        // ------------------------------------------------------------------

        function generateEllipse(cx, cy, rx, ry, cz, count, startAngle = 0, endAngle = Math.PI * 2, group = 0) {
            const pts = [];
            for (let i = 0; i < count; i++) {
                const angle = startAngle + (endAngle - startAngle) * (i / (count - 1));
                pts.push({
                    x: cx + Math.cos(angle) * rx,
                    y: cy + Math.sin(angle) * ry,
                    z: cz,
                    g: group,
                    origY: cy + Math.sin(angle) * ry
                });
            }
            return pts;
        }

        // CUBIC BEZIER (For organic curves: Lips, Eyelids, Nose Profile)
        function generateBezier(x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3, count, group = 0) {
            const pts = [];
            for (let i = 0; i <= count; i++) {
                const t = i / count;
                const it = 1 - t;
                // B(t) = (1-t)^3P0 + 3(1-t)^2tP1 + 3(1-t)t^2P2 + t^3P3
                const x = (it * it * it * x0) + (3 * it * it * t * x1) + (3 * it * t * t * x2) + (t * t * t * x3);
                const y = (it * it * it * y0) + (3 * it * it * t * y1) + (3 * it * t * t * y2) + (t * t * t * y3);
                const z = (it * it * it * z0) + (3 * it * it * t * z1) + (3 * it * t * t * z2) + (t * t * t * z3);
                pts.push({ x, y, z, g: group, origY: y });
            }
            return pts;
        }

        function generateFillDetailed(cx, cy, cz, width, height, depth, count, group = 0) {
            const pts = [];
            for (let i = 0; i < count; i++) {
                const y = (Math.random() - 0.5) * height;
                // Limit fill to an oval shape based on height
                const wAtY = width * Math.sqrt(Math.max(0, 1 - (2*y/height)*(2*y/height))); 
                
                const x = (Math.random() - 0.5) * wAtY;
                // Curve Z based on X (Cylinder wrap)
                const zOffset = Math.sqrt(Math.max(0, (wAtY/2)*(wAtY/2) - x*x)) * (depth/width) - (depth/2);
                
                pts.push({
                    x: cx + x,
                    y: cy + y,
                    z: cz + zOffset,
                    g: group,
                    origY: cy + y
                });
            }
            return pts;
        }

        let faceModel = [];

        function buildFaceModel() {
            // BIOMETRIC FACE SCULPT (Parametric Anatomy)
            faceModel = [];

            // 1. EYES (Orbitals) - Group 1
            // ----------------------------------------------------
            // Left Eye
            const LX = -0.35, LY = -0.2, LZ = -0.1;
            // Upper Lid (Almond)
            faceModel.push(...generateBezier(LX - 0.18, LY, LZ, LX - 0.05, LY - 0.12, LZ, LX + 0.05, LY - 0.12, LZ, LX + 0.18, LY, LZ, 15, 1));
            // Lower Lid (Almond)
            faceModel.push(...generateBezier(LX - 0.18, LY, LZ, LX - 0.05, LY + 0.08, LZ, LX + 0.05, LY + 0.08, LZ, LX + 0.18, LY, LZ, 15, 1));
            // Iris Rings
            faceModel.push(...generateEllipse(LX, LY, 0.09, 0.09, LZ - 0.02, 16, 0, Math.PI * 2, 1));
            faceModel.push(...generateEllipse(LX, LY, 0.05, 0.05, LZ - 0.04, 12, 0, Math.PI * 2, 1));
            // Pupil
            faceModel.push({ x: LX, y: LY, z: LZ - 0.05, g: 1, origY: LY });

            // Right Eye
            const RX = 0.35, RY = -0.2, RZ = -0.1;
            // Upper Lid
            faceModel.push(...generateBezier(RX - 0.18, RY, RZ, RX - 0.05, RY - 0.12, RZ, RX + 0.05, RY - 0.12, RZ, RX + 0.18, RY, RZ, 15, 1));
            // Lower Lid
            faceModel.push(...generateBezier(RX - 0.18, RY, RZ, RX - 0.05, RY + 0.08, RZ, RX + 0.05, RY + 0.08, RZ, RX + 0.18, RY, RZ, 15, 1));
            // Iris
            faceModel.push(...generateEllipse(RX, RY, 0.09, 0.09, RZ - 0.02, 16, 0, Math.PI * 2, 1));
            faceModel.push(...generateEllipse(RX, RY, 0.05, 0.05, RZ - 0.04, 12, 0, Math.PI * 2, 1));
            // Pupil
            faceModel.push({ x: RX, y: RY, z: RZ - 0.05, g: 1, origY: RY });


            // 2. NOSE (Nasal Bone & Cartilage) - Group 2 (Static)
            // ----------------------------------------------------
            // Bridge (Vertical Curve)
            faceModel.push(...generateBezier(0, -0.35, -0.15, 0, -0.2, 0.35, 0, 0.1, 0.45, 0, 0.15, 0.5, 20, 2));
            // Side Bridges (Width)
            faceModel.push(...generateBezier(-0.08, -0.3, -0.05, -0.12, -0.1, 0.2, -0.15, 0.1, 0.25, -0.18, 0.18, 0.2, 20, 2)); // L
            faceModel.push(...generateBezier(0.08, -0.3, -0.05, 0.12, -0.1, 0.2, 0.15, 0.1, 0.25, 0.18, 0.18, 0.2, 20, 2)); // R
            // Nostrils (Loop/Spiral)
            faceModel.push(...generateBezier(-0.05, 0.2, 0.35, -0.12, 0.18, 0.3, -0.15, 0.25, 0.25, -0.02, 0.23, 0.3, 12, 2)); // L
            faceModel.push(...generateBezier(0.05, 0.2, 0.35, 0.12, 0.18, 0.3, 0.15, 0.25, 0.25, 0.02, 0.23, 0.3, 12, 2)); // R
            // Tip Bulb
            faceModel.push(...generateEllipse(0, 0.18, 0.08, 0.06, 0.52, 10, 0, Math.PI * 2, 2));


            // 3. MOUTH (Oral) - Group 3 (Upper) & 4 (Lower)
            // ----------------------------------------------------
            // Cupid's Bow (Upper Lip Top)
            const MY = 0.45;
            faceModel.push(...generateBezier(-0.25, MY, 0.1, -0.15, MY - 0.08, 0.15, -0.05, MY - 0.02, 0.2, 0, MY - 0.05, 0.2, 10, 3)); // L
            faceModel.push(...generateBezier(0, MY - 0.05, 0.2, 0.05, MY - 0.02, 0.2, 0.15, MY - 0.08, 0.15, 0.25, MY, 0.1, 10, 3)); // R
            // Upper Lip Bottom (Meeting line)
            faceModel.push(...generateBezier(-0.25, MY, 0.1, -0.1, MY + 0.02, 0.25, 0.1, MY + 0.02, 0.25, 0.25, MY, 0.1, 20, 3));

            // Lower Lip Top (Meeting line)
            faceModel.push(...generateBezier(-0.25, MY, 0.1, -0.1, MY + 0.02, 0.25, 0.1, MY + 0.02, 0.25, 0.25, MY, 0.1, 20, 4));
            // Lower Lip Bottom (Fullness)
            faceModel.push(...generateBezier(-0.25, MY, 0.1, -0.12, MY + 0.15, 0.2, 0.12, MY + 0.15, 0.2, 0.25, MY, 0.1, 20, 4));


            // 4. FACE CONTOUR (Mandible/Zygomatic) - Group 5
            // ----------------------------------------------------
            // Jawline
            faceModel.push(...generateBezier(-0.6, -0.2, -0.2, -0.55, 0.5, 0.0, -0.25, 0.9, 0.15, 0, 0.95, 0.2, 30, 5)); // L
            faceModel.push(...generateBezier(0.6, -0.2, -0.2, 0.55, 0.5, 0.0, 0.25, 0.9, 0.15, 0, 0.95, 0.2, 30, 5)); // R
            
            // Cheekbones (Zygomatic Arch)
            faceModel.push(...generateBezier(-0.6, -0.1, -0.2, -0.45, -0.05, 0.2, -0.3, 0.3, 0.15, -0.2, 0.45, 0.1, 20, 5)); // L
            faceModel.push(...generateBezier(0.6, -0.1, -0.2, 0.45, -0.05, 0.2, 0.3, 0.3, 0.15, 0.2, 0.45, 0.1, 20, 5)); // R


            // 5. FOREHEAD (Cranium) - Group 0/6
            // ----------------------------------------------------
            // Brow Ridge
            faceModel.push(...generateBezier(-0.5, -0.3, 0.0, -0.2, -0.35, 0.15, 0.2, -0.35, 0.15, 0.5, -0.3, 0.0, 30, 0));
            // Hairline/Top
            faceModel.push(...generateEllipse(0, -0.65, 0.55, 0.25, -0.1, 30, Math.PI, 2*Math.PI, 0));


            // 6. VOLUME FILL (High Density Skin) - Group 6
            // ----------------------------------------------------
            // Cheeks
            faceModel.push(...generateFillDetailed(-0.35, 0.1, 0.1, 0.35, 0.4, 0.3, 200, 6)); // L
            faceModel.push(...generateFillDetailed(0.35, 0.1, 0.1, 0.35, 0.4, 0.3, 200, 6)); // R
            // Forehead
            faceModel.push(...generateFillDetailed(0, -0.45, 0.1, 0.7, 0.3, 0.4, 150, 6));
            // Chin
            faceModel.push(...generateFillDetailed(0, 0.75, 0.15, 0.3, 0.25, 0.2, 60, 5));
            // Nose Bridge Sides
            faceModel.push(...generateFillDetailed(0, -0.1, 0.25, 0.15, 0.5, 0.3, 60, 2));

            // Total nodes: ~1000+
        }

        buildFaceModel();

        // ------------------------------------------------------------------
        // NODE CLASS
        // ------------------------------------------------------------------

        class FaceNode {
            constructor(normX, normY, normZ, group, origY) {
                this.faceNormX = normX;
                this.faceNormY = normY;
                this.faceNormZ = normZ;
                this.group = group;
                this.origNormY = origY;

                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos((Math.random() * 2) - 1);
                this.sphereNormX = Math.sin(phi) * Math.cos(theta);
                this.sphereNormY = Math.sin(phi) * Math.sin(theta);
                this.sphereNormZ = Math.cos(phi);

                // INITIAL POSITION: IMPLOSION
                // Initialize far away if first run
                this.x = (Math.random() - 0.5) * window.innerWidth * 5;
                this.y = (Math.random() - 0.5) * window.innerHeight * 5;
                this.z = (Math.random() - 0.5) * 5000;

                this.faceWorldX = 0; this.faceWorldY = 0; this.faceWorldZ = 0;
                this.sphereWorldX = 0; this.sphereWorldY = 0; this.sphereWorldZ = 0;

                this.phase = Math.random() * Math.PI * 2;
                this.audioOffsetY = 0;
            }

            calculateTargets(centerX, centerY, scale) {
                this.faceWorldX = centerX + this.faceNormX * scale;
                this.faceWorldY = centerY + this.faceNormY * scale;
                this.faceWorldZ = this.faceNormZ * scale;

                if (this.group === 1) {
                    this.eyeCenterY = centerY + (-0.2) * scale;
                }

                this.sphereRadius = scale * 0.85;
                this.sphereWorldX = centerX + this.sphereNormX * this.sphereRadius;
                this.sphereWorldY = centerY + this.sphereNormY * this.sphereRadius;
                this.sphereWorldZ = this.sphereNormZ * this.sphereRadius;

                // On resize (not first spawn), snap to sphere target to prevent re-explosion
                if (!isFirstSpawn) {
                    this.x = this.sphereWorldX;
                    this.y = this.sphereWorldY;
                    this.z = this.sphereWorldZ;
                }
            }

            update(time, audioLevel, state) {
                let tx, ty, tz;

                if (state === 'FACE') {
                    // TRACKING MAPPED TO ROTATION
                    const lookX = trackingX * 0.8; // Reduced range (was 1.5)
                    const lookY = trackingY * 0.6; // Reduced range (was 1.0)

                    currentYaw += (lookX - currentYaw) * config.lookSpeed;
                    currentPitch += (lookY - currentPitch) * config.lookSpeed;

                    let bx = this.faceWorldX - width / 2;
                    let by = this.faceWorldY - height / 2;
                    let bz = this.faceWorldZ;

                    if (this.group === 1) {
                        const localY = this.faceWorldY - this.eyeCenterY;
                        const blinkedY = localY * (1 - blinkValue);
                        by = (this.eyeCenterY + blinkedY) - height / 2;
                    }

                    let audioMoveY = 0;
                    if (isAudioInitialized) {
                        const sensitivity = audioLevel / 255;
                        const S = config.audioSensitivity;
                        if (this.group === 5) audioMoveY = sensitivity * 80 * S; // Jaw: Boosted to 80
                        else if (this.group === 4) audioMoveY = sensitivity * 80 * S; // Lower Lip: Boosted to 80
                        else if (this.group === 3) audioMoveY = -sensitivity * 60 * S; // Upper Lip: Boosted to -60
                    }
                    this.audioOffsetY += (audioMoveY - this.audioOffsetY) * 0.4;
                    by += this.audioOffsetY;

                    let x1 = bx * Math.cos(currentYaw) - bz * Math.sin(currentYaw);
                    let z1 = bx * Math.sin(currentYaw) + bz * Math.cos(currentYaw);
                    let y2 = by * Math.cos(currentPitch) - z1 * Math.sin(currentPitch);
                    let z2 = by * Math.sin(currentPitch) + z1 * Math.cos(currentPitch);

                    tx = width / 2 + x1;
                    ty = height / 2 + y2;
                    tz = z2;

                    tx += Math.sin(time * 0.001 + this.phase) * 0.5;
                    ty += Math.cos(time * 0.002 + this.phase) * 0.5;

                } else {
                    // SPHERE
                    const rotationSpeed = time * 0.0005;
                    const cosR = Math.cos(rotationSpeed);
                    const sinR = Math.sin(rotationSpeed);

                    const rotX = this.sphereNormX * cosR - this.sphereNormZ * sinR;
                    const rotZ = this.sphereNormX * sinR + this.sphereNormZ * cosR;

                    tx = (width / 2) + rotX * this.sphereRadius;
                    ty = (height / 2) + this.sphereNormY * this.sphereRadius;
                    tz = rotZ * this.sphereRadius;

                    tx += Math.sin(time * 0.002 + this.phase) * 5;
                    ty += Math.cos(time * 0.003 + this.phase) * 5;
                }

                // If this is the STARTUP IMPLOSION, we might want a slightly different speed?
                // The standard transitionSpeedToSphere (0.02) is actually quite nice for a slow fly-in.
                const lerpSpeed = (state === 'FACE') ? config.transitionSpeedToFace : config.transitionSpeedToSphere;
                this.x += (tx - this.x) * lerpSpeed;
                this.y += (ty - this.y) * lerpSpeed;
                this.z += (tz - this.z) * lerpSpeed;
            }

            draw() {
                const perspective = 300;
                const dist = perspective - this.z;

                // SAFETY: If point is behind camera or too close (dist < 10), don't draw
                if (dist < 10) return;

                const scale = perspective / dist;

                // SAFETY: If scale is massive (screen filling), skip
                if (scale > 5.0) return;

                ctx.beginPath();
                ctx.arc(this.x, this.y, config.nodeRadius * scale, 0, Math.PI * 2);
                ctx.fillStyle = config.nodeColor;
                ctx.fill();
            }
        }

        // ------------------------------------------------------------------
        // APP LOGIC
        // ------------------------------------------------------------------

        function recenterNodes(explode = true) {
            nodes = [];
            const centerX = width / 2;
            const centerY = (height / 2) + 0;
            const scale = Math.min(width, height) * 0.40;

            // On first call (from script load), explode is true.
            // On resize, we pass false manually.

            faceModel.forEach(p => {
                const node = new FaceNode(p.x, p.y, p.z || 0, p.g, p.origY);
                node.calculateTargets(centerX, centerY, scale);
                nodes.push(node);
            });

            // Disable explosion for future operations (like resize, if logic changes)
            if (explode && isFirstSpawn) {
                isFirstSpawn = false;
            }
        }

        async function initApp() {
            if (isAudioInitialized) return; // Prevent double init

            try {
                // HIGH RES FOR DISTANCE
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: true,
                    video: { width: 640, height: 480, frameRate: 15 }
                });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.5;
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                const audioSource = audioContext.createMediaStreamSource(stream);
                audioSource.connect(analyser);

                isAudioInitialized = true;
                lastSpeechTime = Date.now();
                centerText.classList.add('hidden');

                video.srcObject = stream;
                video.play();

                const tracker = new tracking.ObjectTracker('face');
                // SCALE 2 = DETECT SMALLER FACES (FURTHER AWAY)
                tracker.setInitialScale(2);
                tracker.setStepSize(2);
                tracker.setEdgesDensity(0.1);

                tracking.track('#video', tracker);

                tracker.on('track', function (event) {
                    if (event.data.length === 0) {
                        trackingX *= 0.95;
                        trackingY *= 0.95;
                        targetStatus.innerText = "SCANNING...";
                        targetStatus.style.color = "#00FF00";
                    } else {
                        const face = event.data[0];
                        const cx = face.x + face.width / 2;
                        const cy = face.y + face.height / 2;
                        // MAPPED TO 640x480 - NO INVERSION based on user feedback
                        const normX = (cx / 640) * 2 - 1;
                        const normY = (cy / 480) * 2 - 1;
                        trackingX = normX;
                        trackingY = normY;
                        targetStatus.innerText = "LOCKED";
                        targetStatus.style.color = "red";
                    }
                });

            } catch (err) {
                console.error('Init Error:', err);
                alert('Access denied. Please allow Microphone and Camera permissions to enable AI senses.');
            }
        }

        function updateBlink(time) {
            const now = Date.now();
            if (blinkState === 0 && now > nextBlinkTime) {
                blinkState = 1;
            }
            if (blinkState === 1) {
                blinkValue += config.blinkSpeed;
                if (blinkValue >= 1) { blinkValue = 1; blinkState = 2; }
            } else if (blinkState === 2) {
                blinkValue -= config.blinkSpeed;
                if (blinkValue <= 0) { blinkValue = 0; blinkState = 0; nextBlinkTime = now + 2000 + Math.random() * 4000; }
            }
        }

        function animate(time) {
            ctx.clearRect(0, 0, width, height);

            let audioVol = 0;
            if (isAudioInitialized) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < 100; i++) sum += dataArray[i];
                audioVol = sum / 100;

                const now = Date.now();
                if (audioVol > config.speechThreshold) {
                    currentState = 'FACE';
                    lastSpeechTime = now;
                } else {
                    if (now - lastSpeechTime > config.silenceTimeout) currentState = 'SPHERE';
                }
            } else {
                currentState = 'SPHERE';
            }

            if (currentState === 'FACE') updateBlink();

            // DRAW BACKLIGHT
            // Pulse with audio or idle sine
            let glowRadius = 200 + (audioVol * 2);
            if (!isAudioInitialized) {
                glowRadius = 200 + Math.sin(time * 0.002) * 30;
            }

            const glow = ctx.createRadialGradient(width / 2, height / 2, 50, width / 2, height / 2, glowRadius * 2);
            glow.addColorStop(0, "rgba(0, 255, 0, 0.25)");
            glow.addColorStop(0.5, "rgba(0, 50, 0, 0.1)");
            glow.addColorStop(1, "rgba(0, 0, 0, 0)");

            ctx.fillStyle = glow;
            ctx.fillRect(0, 0, width, height);

            // UPDATE
            nodes.forEach(n => n.update(time, audioVol, currentState));
            nodes.sort((a, b) => a.z - b.z);

            // DRAW CONNECTIONS
            const maxConnectDist = config.connectionDistance * config.connectionDistance;
            for (let i = 0; i < nodes.length; i++) {
                const nodeA = nodes[i];
                for (let j = i + 1; j < nodes.length; j++) {
                    const nodeB = nodes[j];
                    const dx = nodeA.x - nodeB.x;
                    if (Math.abs(dx) > config.connectionDistance) continue;
                    const dy = nodeA.y - nodeB.y;
                    if (Math.abs(dy) > config.connectionDistance) continue;
                    const dz = nodeA.z - nodeB.z;
                    if (Math.abs(dz) > config.connectionDistance) continue;

                    const distSq = dx * dx + dy * dy + dz * dz;
                    if (distSq < maxConnectDist) {
                        const alpha = 1 - (distSq / maxConnectDist);
                        ctx.strokeStyle = `rgba(0, 255, 0, ${alpha * 0.35})`;
                        ctx.beginPath();
                        ctx.moveTo(nodeA.x, nodeA.y);
                        ctx.lineTo(nodeB.x, nodeB.y);
                        ctx.stroke();
                    }
                }
            }

            // DRAW NODES
            nodes.forEach(n => n.draw());

            requestAnimationFrame(animate);
        }

        // Initialize with IMPLOSION
        resize(); // Calls checkNodes -> triggers first spawn explosion
        animate(0);

        // Click Anywhere to Start
        document.addEventListener('click', () => initApp());

    </script>
</body>

</html>