<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S.A.I.A. - Strategic Artificial Intelligence Avatar</title>

    <!-- Tracking.js for Face Detection -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tracking.js/1.1.3/tracking-min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tracking.js/1.1.3/data/face-min.js"></script>

    <style>
        body {
            background-color: #000000;
            color: #00FF00;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            cursor: pointer;
            /* Indicate clickable */
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: radical-gradient(circle at center, #051a05 0%, #000000 70%);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-text {
            font-size: 14px;
            opacity: 0.7;
            text-shadow: 0 0 5px #00FF00;
        }

        #center-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.2rem;
            color: #00FF00;
            opacity: 0.5;
            text-align: center;
            letter-spacing: 2px;
            animation: pulse 2s infinite;
            pointer-events: none;
        }

        @keyframes pulse {
            0% {
                opacity: 0.3;
            }

            50% {
                opacity: 0.8;
            }

            100% {
                opacity: 0.3;
            }
        }

        .hidden {
            display: none !important;
        }

        #video {
            position: absolute;
            top: -1000px;
            left: -1000px;
            visibility: hidden;
        }
    </style>
</head>

<body>

    <div id="canvas-container">
        <canvas id="faceCanvas"></canvas>
        <div id="ui-layer">
            <div class="hud-text">SYSTEM: ONLINE<br>TARGET: <span id="target-status">SCANNING...</span></div>
            <div class="hud-text" style="text-align: right;">CPU: 04%<br>MEM: 512TB</div>
        </div>

        <div id="center-text">
            SYSTEM STANDBY<br>
            [ TOUCH TERMINAL TO ENGAGE ]
        </div>

        <!-- Video for Head Tracking -->
        <video id="video" width="640" height="480" preload autoplay loop muted></video>
    </div>

    <script>
        const canvas = document.getElementById('faceCanvas');
        const ctx = canvas.getContext('2d');
        const centerText = document.getElementById('center-text');
        const targetStatus = document.getElementById('target-status');
        const video = document.getElementById('video');

        let width, height;
        let audioContext, analyser, dataArray;
        let nodes = [];
        let isAudioInitialized = false;
        let lastSpeechTime = 0;
        let currentState = 'SPHERE';

        // ARTIFACTS FOR SMART BEHAVIOR
        let trackingX = 0;
        let trackingY = 0;

        let currentYaw = 0;
        let currentPitch = 0;

        let blinkState = 0;
        let blinkValue = 0;
        let nextBlinkTime = Date.now() + 3000;

        // IMPLOSION STATE
        let isFirstSpawn = true;

        // CONFIGURATION
        const config = {
            nodeColor: '#00FF00',
            lineColor: 'rgba(0, 255, 0, 0.12)',
            connectionDistance: 45, // Slightly increased for cranium connection
            nodeRadius: 0.8,
            idleAmplitude: 2.0,
            idleSpeed: 0.0015,
            audioSensitivity: 1.5,
            sphereRadiusRatio: 0.35,
            silenceTimeout: 10000,
            speechThreshold: 5,
            transitionSpeedToFace: 0.15,
            transitionSpeedToSphere: 0.02,
            lookSpeed: 0.05,
            blinkSpeed: 0.2
        };

        // Resize
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            recenterNodes(false); // Do not re-explode on resize
        }
        window.addEventListener('resize', resize);

        // ------------------------------------------------------------------
        // 3D GEOMETRY GENERATION
        // ------------------------------------------------------------------

        function generateEllipse(cx, cy, rx, ry, cz, count, startAngle = 0, endAngle = Math.PI * 2, group = 0) {
            const pts = [];
            for (let i = 0; i < count; i++) {
                const angle = startAngle + (endAngle - startAngle) * (i / (count - 1));
                pts.push({
                    x: cx + Math.cos(angle) * rx,
                    y: cy + Math.sin(angle) * ry,
                    z: cz,
                    g: group,
                    origY: cy + Math.sin(angle) * ry
                });
            }
            return pts;
        }

        // CUBIC BEZIER (For organic curves)
        function generateBezier(x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3, count, group = 0) {
            const pts = [];
            for (let i = 0; i <= count; i++) {
                const t = i / count;
                const it = 1 - t;
                // B(t) = (1-t)^3P0 + 3(1-t)^2tP1 + 3(1-t)t^2P2 + t^3P3
                const x = (it * it * it * x0) + (3 * it * it * t * x1) + (3 * it * t * t * x2) + (t * t * t * x3);
                const y = (it * it * it * y0) + (3 * it * it * t * y1) + (3 * it * t * t * y2) + (t * t * t * y3);
                const z = (it * it * it * z0) + (3 * it * it * t * z1) + (3 * it * t * t * z2) + (t * t * t * z3);
                pts.push({ x, y, z, g: group, origY: y });
            }
            return pts;
        }

        function generateFillDetailed(cx, cy, cz, width, height, depth, count, group = 0) {
            const pts = [];
            for (let i = 0; i < count; i++) {
                const y = (Math.random() - 0.5) * height;
                // Limit fill to an oval shape based on height
                const wAtY = width * Math.sqrt(Math.max(0, 1 - (2*y/height)*(2*y/height))); 
                
                const x = (Math.random() - 0.5) * wAtY;
                // Curve Z based on X (Cylinder wrap)
                const zOffset = Math.sqrt(Math.max(0, (wAtY/2)*(wAtY/2) - x*x)) * (depth/width) - (depth/2);
                
                pts.push({
                    x: cx + x,
                    y: cy + y,
                    z: cz + zOffset,
                    g: group,
                    origY: cy + y
                });
            }
            return pts;
        }

        let faceModel = [];

        function buildFaceModel() {
            faceModel = [];

            // 1. EYES (Orbitals) - Group 1
            const LX = -0.35, LY = -0.2, LZ = -0.1;
            faceModel.push(...generateBezier(LX - 0.18, LY, LZ, LX - 0.05, LY - 0.12, LZ, LX + 0.05, LY - 0.12, LZ, LX + 0.18, LY, LZ, 15, 1)); // Upper Lid
            faceModel.push(...generateBezier(LX - 0.18, LY, LZ, LX - 0.05, LY + 0.08, LZ, LX + 0.05, LY + 0.08, LZ, LX + 0.18, LY, LZ, 15, 1)); // Lower Lid
            faceModel.push(...generateEllipse(LX, LY, 0.09, 0.09, LZ - 0.02, 16, 0, Math.PI * 2, 1)); // Iris
            faceModel.push({ x: LX, y: LY, z: LZ - 0.05, g: 1, origY: LY }); // Pupil

            const RX = 0.35, RY = -0.2, RZ = -0.1;
            faceModel.push(...generateBezier(RX - 0.18, RY, RZ, RX - 0.05, RY - 0.12, RZ, RX + 0.05, RY - 0.12, RZ, RX + 0.18, RY, RZ, 15, 1)); // Upper Lid
            faceModel.push(...generateBezier(RX - 0.18, RY, RZ, RX - 0.05, RY + 0.08, RZ, RX + 0.05, RY + 0.08, RZ, RX + 0.18, RY, RZ, 15, 1)); // Lower Lid
            faceModel.push(...generateEllipse(RX, RY, 0.09, 0.09, RZ - 0.02, 16, 0, Math.PI * 2, 1)); // Iris
            faceModel.push({ x: RX, y: RY, z: RZ - 0.05, g: 1, origY: RY }); // Pupil

            // 2. NOSE (Nasal Bone) - Group 2
            faceModel.push(...generateBezier(0, -0.35, -0.15, 0, -0.2, 0.35, 0, 0.1, 0.45, 0, 0.15, 0.5, 20, 2)); // Bridge
            faceModel.push(...generateBezier(-0.08, -0.3, -0.05, -0.12, -0.1, 0.2, -0.15, 0.1, 0.25, -0.18, 0.18, 0.2, 20, 2)); // L Side
            faceModel.push(...generateBezier(0.08, -0.3, -0.05, 0.12, -0.1, 0.2, 0.15, 0.1, 0.25, 0.18, 0.18, 0.2, 20, 2)); // R Side
            faceModel.push(...generateBezier(-0.05, 0.2, 0.35, -0.12, 0.18, 0.3, -0.15, 0.25, 0.25, -0.02, 0.23, 0.3, 12, 2)); // L Nostril
            faceModel.push(...generateBezier(0.05, 0.2, 0.35, 0.12, 0.18, 0.3, 0.15, 0.25, 0.25, 0.02, 0.23, 0.3, 12, 2)); // R Nostril
            faceModel.push(...generateBezier(-0.02, 0.23, 0.3, 0, 0.25, 0.55, 0, 0.25, 0.55, 0.02, 0.23, 0.3, 10, 2)); // Tip Loop

            // 3. ADVANCED VOLUMETRIC MOUTH (Groups 3/4)
            // ----------------------------------------------------
            const MY = 0.45;
            
            // Generate Mesh Function (Vertical Ribbing + Horizontal Contours)
            // Creates a grid: 'rows' are contour lines, 'cols' creates vertical connections
            function generateLipSurface(rowsData, colsInRow, group) {
                // rowsData: array of control points for each Bezier curve row [ {x0,y0...}, {x0,y0...} ]
                const surfacePts = [];
                const rows = [];
                
                // Generate all rows first
                rowsData.forEach(d => {
                    rows.push(generateBezier(d.x0, d.y0, d.z0, d.x1, d.y1, d.z1, d.x2, d.y2, d.z2, d.x3, d.y3, d.z3, colsInRow, group));
                });

                // Add all row points to model
                rows.forEach(r => surfacePts.push(...r));

                // Add VERTICAL RIBBING (Connect row i to row i+1)
                for (let r = 0; r < rows.length - 1; r++) {
                    const rowA = rows[r];
                    const rowB = rows[r+1];
                    // We don't add points, but strictly visualizing connection isn't enough?
                    // Wait, the renderer connects close points. 
                    // So we just need DENSE points in a grid pattern.
                    // To ensure vertical lines, we add intermediate points between rows if needed?
                    // Actually, if connectionDistance is right, they will connect vertically.
                }
                return surfacePts;
            }

            // UPPER LIP (Group 3)
            // Row 1: Vermilion Border (Top Edge) - Sharp
            // Row 2: Mid Pout (Volumetric) - Forward Z
            // Row 3: Wetline (Bottom Edge) - Recessed Z
            
            // Left Upper
            faceModel.push(...generateBezier(-0.25, MY, 0.1, -0.15, MY - 0.08, 0.15, -0.05, MY - 0.02, 0.2, 0, MY - 0.05, 0.2, 15, 3)); // Border
            faceModel.push(...generateBezier(-0.25, MY, 0.1, -0.15, MY - 0.05, 0.25, -0.05, MY + 0.0, 0.35, 0, MY - 0.02, 0.35, 15, 3)); // Pout (Projected)
            faceModel.push(...generateBezier(-0.25, MY, 0.1, -0.15, MY + 0.02, 0.15, -0.05, MY + 0.02, 0.15, 0, MY, 0.15, 15, 3)); // Wetline

            // Right Upper
            faceModel.push(...generateBezier(0, MY - 0.05, 0.2, 0.05, MY - 0.02, 0.2, 0.15, MY - 0.08, 0.15, 0.25, MY, 0.1, 15, 3)); // Border
            faceModel.push(...generateBezier(0, MY - 0.02, 0.35, 0.05, MY + 0.0, 0.35, 0.15, MY - 0.05, 0.25, 0.25, MY, 0.1, 15, 3)); // Pout
            faceModel.push(...generateBezier(0, MY, 0.15, 0.05, MY + 0.02, 0.15, 0.15, MY + 0.02, 0.15, 0.25, MY, 0.1, 15, 3)); // Wetline


            // LOWER LIP (Group 4)
            // Row 1: Wetline (Top Edge) - Matches Upper Wetline Z
            // Row 2: Mid Pout (Volumetric) - Forward Z (Fuller)
            // Row 3: Vermilion Border (Bottom Edge) - Recessed
            
            // Full Arc (Left to Right)
            faceModel.push(...generateBezier(-0.25, MY, 0.1, -0.12, MY + 0.02, 0.15, 0.12, MY + 0.02, 0.15, 0.25, MY, 0.1, 30, 4)); // Wetline
            faceModel.push(...generateBezier(-0.25, MY, 0.1, -0.12, MY + 0.08, 0.40, 0.12, MY + 0.08, 0.40, 0.25, MY, 0.1, 30, 4)); // Pout (High Z)
            faceModel.push(...generateBezier(-0.25, MY, 0.1, -0.12, MY + 0.15, 0.2, 0.12, MY + 0.15, 0.2, 0.25, MY, 0.1, 30, 4)); // Border


            // 4. FACE CONTOUR EXTENDED (Jaw/Cheek Wrap) - Group 5
            // ----------------------------------------------------
            // Jawline wrapping back to Ear
            faceModel.push(...generateBezier(0, 0.95, 0.2, -0.3, 0.9, 0.15, -0.55, 0.5, 0.0, -0.65, 0.1, 0.2, 40, 5)); // L
            faceModel.push(...generateBezier(0, 0.95, 0.2, 0.3, 0.9, 0.15, 0.55, 0.5, 0.0, 0.65, 0.1, 0.2, 40, 5)); // R

            // Cheekbones wrapping back to Ear Top
            faceModel.push(...generateBezier(-0.2, 0.1, 0.25, -0.35, 0.05, 0.2, -0.55, -0.1, 0.1, -0.65, -0.15, 0.2, 30, 5)); // L
            faceModel.push(...generateBezier(0.2, 0.1, 0.25, 0.35, 0.05, 0.2, 0.55, -0.1, 0.1, 0.65, -0.15, 0.2, 30, 5)); // R


            // 5. TECHNO EARS (Group 7)
            const LEX = -0.7, LEY = -0.05, LEZ = 0.25;
            faceModel.push(...generateBezier(LEX, LEY - 0.2, LEZ, LEX - 0.2, LEY - 0.25, LEZ - 0.05, LEX - 0.2, LEY + 0.15, LEZ - 0.05, LEX, LEY + 0.25, LEZ, 25, 7)); // Outer
            faceModel.push(...generateBezier(LEX + 0.05, LEY - 0.15, LEZ, LEX - 0.15, LEY - 0.20, LEZ - 0.05, LEX - 0.15, LEY + 0.10, LEZ - 0.05, LEX + 0.05, LEY + 0.20, LEZ, 20, 7)); // Inner
            faceModel.push(...generateBezier(LEX + 0.05, LEY + 0.20, LEZ, LEX + 0.08, LEY + 0.0, LEZ + 0.02, LEX + 0.08, LEY - 0.05, LEZ + 0.02, LEX + 0.05, LEY - 0.15, LEZ, 15, 7)); // Antihelix
            faceModel.push({ x: LEX + 0.1, y: LEY + 0.05, z: LEZ + 0.05, g: 7, origY: LEY });

            const REX = 0.7, REY = -0.05, REZ = 0.25;
            faceModel.push(...generateBezier(REX, REY - 0.2, REZ, REX + 0.2, REY - 0.25, REZ - 0.05, REX + 0.2, REY + 0.15, REZ - 0.05, REX, REY + 0.25, REZ, 25, 7)); // Outer
            faceModel.push(...generateBezier(REX - 0.05, REY - 0.15, REZ, REX + 0.15, REY - 0.20, REZ - 0.05, REX + 0.15, REY + 0.10, REZ - 0.05, REX - 0.05, REY + 0.20, REZ, 20, 7)); // Inner
            faceModel.push(...generateBezier(REX - 0.05, REY + 0.20, REZ, REX - 0.08, REY + 0.0, REZ + 0.02, REX - 0.08, REY - 0.05, REZ + 0.02, REX - 0.05, REY - 0.15, REZ, 15, 7)); // Antihelix
             faceModel.push({ x: REX - 0.1, y: REY + 0.05, z: REZ + 0.05, g: 7, origY: REY });


            // 6. CRANIUM (Group 8)
            faceModel.push(...generateBezier(0, -0.65, 0.25, 0, -0.85, 0.1, 0, -0.85, -0.5, 0, -0.5, -0.8, 40, 8));
            faceModel.push(...generateBezier(-0.55, -0.4, 0.1, -0.65, -0.6, 0.0, -0.65, -0.6, -0.5, -0.4, -0.4, -0.75, 35, 8)); // L
            faceModel.push(...generateBezier(0.55, -0.4, 0.1, 0.65, -0.6, 0.0, 0.65, -0.6, -0.5, 0.4, -0.4, -0.75, 35, 8)); // R
            faceModel.push(...generateBezier(-0.65, 0.1, 0.2, -0.6, 0.3, -0.4, -0.2, 0.5, -0.7, 0, 0.5, -0.8, 25, 8)); // L Quarter
            faceModel.push(...generateBezier(0.65, 0.1, 0.2, 0.6, 0.3, -0.4, 0.2, 0.5, -0.7, 0, 0.5, -0.8, 25, 8)); // R Quarter
            faceModel.push(...generateEllipse(0, -0.2, 0.6, 0.65, -0.5, 40, Math.PI, 2 * Math.PI, 8)); // Upper
            faceModel.push(...generateEllipse(0, 0.2, 0.55, 0.6, -0.6, 40, Math.PI, 2 * Math.PI, 8)); // Mid


            // 7. VOLUME FILLS (Group 6)
            faceModel.push(...generateFillDetailed(-0.35, 0.1, 0.1, 0.35, 0.4, 0.3, 200, 6)); // L Cheek
            faceModel.push(...generateFillDetailed(0.35, 0.1, 0.1, 0.35, 0.4, 0.3, 200, 6)); // R Cheek
            faceModel.push(...generateFillDetailed(0, -0.45, 0.1, 0.7, 0.3, 0.4, 150, 6)); // Forehead
            faceModel.push(...generateFillDetailed(0, 0.75, 0.15, 0.3, 0.25, 0.2, 60, 5)); // Chin
            faceModel.push(...generateFillDetailed(0, -0.1, 0.25, 0.15, 0.5, 0.3, 60, 2)); // Nose Bridge

            // 8. TEMPORAL DATA LINES (Group 9)
            const T_StartL = -0.55, T_EndL = -0.7;
            faceModel.push(...generateBezier(T_StartL, -0.2, 0.1, -0.6, -0.2, 0.1, -0.65, -0.2, 0.15, T_EndL, -0.15, 0.25, 10, 9));
            faceModel.push(...generateBezier(T_StartL, 0.0, 0.1, -0.6, 0.0, 0.1, -0.65, 0.0, 0.15, T_EndL, 0.05, 0.25, 10, 9));
            faceModel.push(...generateBezier(T_StartL, 0.2, 0.1, -0.65, 0.25, 0.15, -0.68, 0.3, 0.2, -0.65, 0.1, 0.2, 10, 9));

            const T_StartR = 0.55, T_EndR = 0.7;
            faceModel.push(...generateBezier(T_StartR, -0.2, 0.1, 0.6, -0.2, 0.1, 0.65, -0.2, 0.15, T_EndR, -0.15, 0.25, 10, 9));
            faceModel.push(...generateBezier(T_StartR, 0.0, 0.1, 0.6, 0.0, 0.1, 0.65, 0.0, 0.15, T_EndR, 0.05, 0.25, 10, 9));
            faceModel.push(...generateBezier(T_StartR, 0.2, 0.1, 0.65, 0.25, 0.15, 0.68, 0.3, 0.2, 0.65, 0.1, 0.2, 10, 9));


            // 9. SUBMANDIBULAR MESH (Group 10)
            faceModel.push(...generateBezier(0, 0.95, 0.2, 0, 1.0, 0.0, 0, 0.8, -0.3, 0, 0.5, -0.5, 20, 10));
            faceModel.push(...generateBezier(-0.2, 0.9, 0.15, -0.3, 0.95, -0.1, -0.5, 0.8, -0.3, -0.55, 0.5, -0.4, 20, 10)); // L
            faceModel.push(...generateBezier(0.2, 0.9, 0.15, 0.3, 0.95, -0.1, 0.5, 0.8, -0.3, 0.55, 0.5, -0.4, 20, 10)); // R
        }

        buildFaceModel();

        // ------------------------------------------------------------------
        // NODE CLASS
        // ------------------------------------------------------------------

        class FaceNode {
            constructor(normX, normY, normZ, group, origY) {
                this.faceNormX = normX;
                this.faceNormY = normY;
                this.faceNormZ = normZ;
                this.group = group;
                this.origNormY = origY;

                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos((Math.random() * 2) - 1);
                this.sphereNormX = Math.sin(phi) * Math.cos(theta);
                this.sphereNormY = Math.sin(phi) * Math.sin(theta);
                this.sphereNormZ = Math.cos(phi);

                // INITIAL POSITION: IMPLOSION
                this.x = (Math.random() - 0.5) * window.innerWidth * 5;
                this.y = (Math.random() - 0.5) * window.innerHeight * 5;
                this.z = (Math.random() - 0.5) * 5000;

                this.faceWorldX = 0; this.faceWorldY = 0; this.faceWorldZ = 0;
                this.sphereWorldX = 0; this.sphereWorldY = 0; this.sphereWorldZ = 0;

                this.phase = Math.random() * Math.PI * 2;
                this.audioOffsetY = 0;
            }

            calculateTargets(centerX, centerY, scale) {
                this.faceWorldX = centerX + this.faceNormX * scale;
                this.faceWorldY = centerY + this.faceNormY * scale;
                this.faceWorldZ = this.faceNormZ * scale;

                if (this.group === 1) {
                    this.eyeCenterY = centerY + (-0.2) * scale;
                }

                this.sphereRadius = scale * 0.85;
                this.sphereWorldX = centerX + this.sphereNormX * this.sphereRadius;
                this.sphereWorldY = centerY + this.sphereNormY * this.sphereRadius;
                this.sphereWorldZ = this.sphereNormZ * this.sphereRadius;

                // On resize (not first spawn), snap to sphere target
                if (!isFirstSpawn) {
                    this.x = this.sphereWorldX;
                    this.y = this.sphereWorldY;
                    this.z = this.sphereWorldZ;
                }
            }

            update(time, audioLevel, state) {
                let tx, ty, tz;

                if (state === 'FACE') {
                    // TRACKING MAPPED TO ROTATION
                    const lookX = trackingX * 0.8; 
                    const lookY = trackingY * 0.6; 

                    currentYaw += (lookX - currentYaw) * config.lookSpeed;
                    currentPitch += (lookY - currentPitch) * config.lookSpeed;

                    let bx = this.faceWorldX - width / 2;
                    let by = this.faceWorldY - height / 2;
                    let bz = this.faceWorldZ;

                    if (this.group === 1) {
                        const localY = this.faceWorldY - this.eyeCenterY;
                        const blinkedY = localY * (1 - blinkValue);
                        by = (this.eyeCenterY + blinkedY) - height / 2;
                    }

                    let audioMoveY = 0;
                    if (isAudioInitialized) {
                        const sensitivity = audioLevel / 255;
                        const S = config.audioSensitivity;
                        if (this.group === 5) audioMoveY = sensitivity * 80 * S; // Jaw
                        else if (this.group === 4) audioMoveY = sensitivity * 80 * S; // Lower Lip
                        else if (this.group === 3) audioMoveY = -sensitivity * 60 * S; // Upper Lip
                        else if (this.group === 10) audioMoveY = sensitivity * 30 * S; // Throat
                    }
                    this.audioOffsetY += (audioMoveY - this.audioOffsetY) * 0.4;
                    by += this.audioOffsetY;

                    let x1 = bx * Math.cos(currentYaw) - bz * Math.sin(currentYaw);
                    let z1 = bx * Math.sin(currentYaw) + bz * Math.cos(currentYaw);
                    let y2 = by * Math.cos(currentPitch) - z1 * Math.sin(currentPitch);
                    let z2 = by * Math.sin(currentPitch) + z1 * Math.cos(currentPitch);

                    tx = width / 2 + x1;
                    ty = height / 2 + y2;
                    tz = z2;

                    tx += Math.sin(time * 0.001 + this.phase) * 0.5;
                    ty += Math.cos(time * 0.002 + this.phase) * 0.5;

                } else {
                    // SPHERE
                    const rotationSpeed = time * 0.0005;
                    const cosR = Math.cos(rotationSpeed);
                    const sinR = Math.sin(rotationSpeed);

                    const rotX = this.sphereNormX * cosR - this.sphereNormZ * sinR;
                    const rotZ = this.sphereNormX * sinR + this.sphereNormZ * cosR;

                    tx = (width / 2) + rotX * this.sphereRadius;
                    ty = (height / 2) + this.sphereNormY * this.sphereRadius;
                    tz = rotZ * this.sphereRadius;

                    tx += Math.sin(time * 0.002 + this.phase) * 5;
                    ty += Math.cos(time * 0.003 + this.phase) * 5;
                }

                const lerpSpeed = (state === 'FACE') ? config.transitionSpeedToFace : config.transitionSpeedToSphere;
                this.x += (tx - this.x) * lerpSpeed;
                this.y += (ty - this.y) * lerpSpeed;
                this.z += (tz - this.z) * lerpSpeed;
            }

            draw() {
                const perspective = 300;
                const dist = perspective - this.z;
                if (dist < 10) return;
                const scale = perspective / dist;
                if (scale > 5.0) return;

                ctx.beginPath();
                ctx.arc(this.x, this.y, config.nodeRadius * scale, 0, Math.PI * 2);
                ctx.fillStyle = config.nodeColor;
                ctx.fill();
            }
        }

        function recenterNodes(explode = true) {
            nodes = [];
            const centerX = width / 2;
            const centerY = (height / 2) + 0;
            const scale = Math.min(width, height) * 0.40;

            faceModel.forEach(p => {
                const node = new FaceNode(p.x, p.y, p.z || 0, p.g, p.origY);
                node.calculateTargets(centerX, centerY, scale);
                nodes.push(node);
            });

            if (explode && isFirstSpawn) {
                isFirstSpawn = false;
            }
        }

        async function initApp() {
            if (isAudioInitialized) return;

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: true,
                    video: { width: 640, height: 480, frameRate: 15 }
                });

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = 0.5;
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                const audioSource = audioContext.createMediaStreamSource(stream);
                audioSource.connect(analyser);

                isAudioInitialized = true;
                lastSpeechTime = Date.now();
                centerText.classList.add('hidden');

                video.srcObject = stream;
                video.play();

                const tracker = new tracking.ObjectTracker('face');
                tracker.setInitialScale(2);
                tracker.setStepSize(2);
                tracker.setEdgesDensity(0.1);

                tracking.track('#video', tracker);

                tracker.on('track', function (event) {
                    if (event.data.length === 0) {
                        trackingX *= 0.95;
                        trackingY *= 0.95;
                        targetStatus.innerText = "SCANNING...";
                        targetStatus.style.color = "#00FF00";
                    } else {
                        const face = event.data[0];
                        const cx = face.x + face.width / 2;
                        const cy = face.y + face.height / 2;
                        const normX = (cx / 640) * 2 - 1;
                        const normY = (cy / 480) * 2 - 1;
                        trackingX = normX;
                        trackingY = normY;
                        targetStatus.innerText = "LOCKED";
                        targetStatus.style.color = "red";
                    }
                });

            } catch (err) {
                console.error('Init Error:', err);
                alert('Access denied. Please allow Microphone and Camera permissions to enable AI senses.');
            }
        }

        function updateBlink(time) {
            const now = Date.now();
            if (blinkState === 0 && now > nextBlinkTime) {
                blinkState = 1;
            }
            if (blinkState === 1) {
                blinkValue += config.blinkSpeed;
                if (blinkValue >= 1) { blinkValue = 1; blinkState = 2; }
            } else if (blinkState === 2) {
                blinkValue -= config.blinkSpeed;
                if (blinkValue <= 0) { blinkValue = 0; blinkState = 0; nextBlinkTime = now + 2000 + Math.random() * 4000; }
            }
        }

        function animate(time) {
            ctx.clearRect(0, 0, width, height);

            let audioVol = 0;
            if (isAudioInitialized) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for (let i = 0; i < 100; i++) sum += dataArray[i];
                audioVol = sum / 100;

                const now = Date.now();
                if (audioVol > config.speechThreshold) {
                    currentState = 'FACE';
                    lastSpeechTime = now;
                } else {
                    if (now - lastSpeechTime > config.silenceTimeout) currentState = 'SPHERE';
                }
            } else {
                currentState = 'SPHERE';
            }

            if (currentState === 'FACE') updateBlink();

            let glowRadius = 200 + (audioVol * 2);
            if (!isAudioInitialized) glowRadius = 200 + Math.sin(time * 0.002) * 30;

            const glow = ctx.createRadialGradient(width / 2, height / 2, 50, width / 2, height / 2, glowRadius * 2);
            glow.addColorStop(0, "rgba(0, 255, 0, 0.25)");
            glow.addColorStop(0.5, "rgba(0, 50, 0, 0.1)");
            glow.addColorStop(1, "rgba(0, 0, 0, 0)");

            ctx.fillStyle = glow;
            ctx.fillRect(0, 0, width, height);

            nodes.forEach(n => n.update(time, audioVol, currentState));
            nodes.sort((a, b) => a.z - b.z);

            const maxConnectDist = config.connectionDistance * config.connectionDistance;
            for (let i = 0; i < nodes.length; i++) {
                const nodeA = nodes[i];
                for (let j = i + 1; j < nodes.length; j++) {
                    const nodeB = nodes[j];
                    const dx = nodeA.x - nodeB.x;
                    if (Math.abs(dx) > config.connectionDistance) continue;
                    const dy = nodeA.y - nodeB.y;
                    if (Math.abs(dy) > config.connectionDistance) continue;
                    const dz = nodeA.z - nodeB.z;
                    if (Math.abs(dz) > config.connectionDistance) continue;

                    const distSq = dx * dx + dy * dy + dz * dz;
                    if (distSq < maxConnectDist) {
                        const alpha = 1 - (distSq / maxConnectDist);
                        ctx.strokeStyle = `rgba(0, 255, 0, ${alpha * 0.35})`;
                        ctx.beginPath();
                        ctx.moveTo(nodeA.x, nodeA.y);
                        ctx.lineTo(nodeB.x, nodeB.y);
                        ctx.stroke();
                    }
                }
            }

            nodes.forEach(n => n.draw());
            requestAnimationFrame(animate);
        }

        resize();
        animate(0);

        document.addEventListener('click', () => initApp());

    </script>
</body>

</html>